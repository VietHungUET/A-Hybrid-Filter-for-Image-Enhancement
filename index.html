<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Filter Image Processing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-4xl">
        <h1 class="text-2xl font-bold mb-4 text-center">Hybrid Filter for Image Enhancement</h1>
        
        <!-- Input Section -->
        <div class="mb-4">
            <label class="block mb-2 font-semibold">Upload Image:</label>
            <input type="file" id="imageInput" accept="image/*" class="w-full p-2 border rounded">
        </div>
        
        <!-- Parameters -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div>
                <label class="block mb-1">Window Size:</label>
                <select id="windowSize" class="w-full p-2 border rounded">
                    <option value="3">3x3</option>
                    <option value="5">5x5</option>
                    <option value="7">7x7</option>
                </select>
            </div>
            <div>
                <label class="block mb-1">Threshold (Impulsive Noise):</label>
                <input type="range" id="threshold" min="10" max="100" value="50" class="w-full">
                <span id="thresholdValue" class="block text-center">50</span>
            </div>
            <div>
                <label class="block mb-1">Sigma (Fuzzy Weights):</label>
                <input type="range" id="sigma" min="10" max="100" value="30" class="w-full">
                <span id="sigmaValue" class="block text-center">30</span>
            </div>
        </div>
        
        <!-- Apply Button -->
        <button id="applyFilter" class="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 mb-4">Apply Filter</button>
        
        <!-- Canvases -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
                <h2 class="text-lg font-semibold mb-2">Original Image</h2>
                <canvas id="originalCanvas" class="border"></canvas>
            </div>
            <div>
                <h2 class="text-lg font-semibold mb-2">Filtered Image</h2>
                <canvas id="filteredCanvas" class="border"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const imageInput = document.getElementById('imageInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const filteredCanvas = document.getElementById('filteredCanvas');
        const applyFilterButton = document.getElementById('applyFilter');
        const windowSizeSelect = document.getElementById('windowSize');
        const thresholdInput = document.getElementById('threshold');
        const sigmaInput = document.getElementById('sigma');
        const thresholdValue = document.getElementById('thresholdValue');
        const sigmaValue = document.getElementById('sigmaValue');

        // Update slider values
        thresholdInput.addEventListener('input', () => {
            thresholdValue.textContent = thresholdInput.value;
        });
        sigmaInput.addEventListener('input', () => {
            sigmaValue.textContent = sigmaInput.value;
        });

        // Handle image upload
        let originalImageData = null;
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = () => {
                    // Set canvas dimensions
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    filteredCanvas.width = img.width;
                    filteredCanvas.height = img.height;

                    // Draw original image
                    const ctx = originalCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    originalImageData = ctx.getImageData(0, 0, img.width, img.height);
                };
                img.src = URL.createObjectURL(file);
            }
        });

        // Apply hybrid filter
        applyFilterButton.addEventListener('click', () => {
            if (!originalImageData) {
                alert('Please upload an image first!');
                return;
            }

            const windowSize = parseInt(windowSizeSelect.value);
            const threshold = parseFloat(thresholdInput.value);
            const sigma = parseFloat(sigmaInput.value);

            // Process image
            const filteredImageData = hybridFilter(originalImageData, windowSize, threshold, sigma);

            // Draw filtered image
            const ctx = filteredCanvas.getContext('2d');
            ctx.putImageData(filteredImageData, 0, 0);
        });

        function hybridFilter(imageData, windowSize, threshold, sigma) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const N = Math.floor(windowSize / 2);

            // Step 1: Selective Peeling (Impulsive Noise Removal)
            const peeledData = new Uint8ClampedArray(data.length);
            peeledData.set(data);

            // Helper function to get pixel value (grayscale)
            function getPixel(x, y, dataArray) {
                const index = (y * width + x) * 4;
                // Convert to grayscale (average of RGB)
                return (dataArray[index] + dataArray[index + 1] + dataArray[index + 2]) / 3;
            }

            // Helper function to set pixel value (grayscale to RGB)
            function setPixel(x, y, value, dataArray) {
                const index = (y * width + x) * 4;
                dataArray[index] = value;     // R
                dataArray[index + 1] = value; // G
                dataArray[index + 2] = value; // B
                dataArray[index + 3] = 255;   // A
            }

            // Compute median for a window
            function getMedian(window) {
                const values = window.slice().sort((a, b) => a - b);
                const mid = Math.floor(values.length / 2);
                return values.length % 2 === 0 ? (values[mid - 1] + values[mid]) / 2 : values[mid];
            }

            // Selective peeling
            for (let y = N; y < height - N; y++) {
                for (let x = N; x < width - N; x++) {
                    // Extract window
                    const window = [];
                    for (let j = -N; j <= N; j++) {
                        for (let i = -N; i <= N; i++) {
                            window.push(getPixel(x + i, y + j, data));
                        }
                    }
                    const median = getMedian(window);

                    // Check center pixel
                    const centerVal = getPixel(x, y, data);
                    if (Math.abs(centerVal - median) > threshold) {
                        setPixel(x, y, median, peeledData);
                    }
                }
            }

            // Step 2: Fuzzy Weighted Averaging (Gaussian Noise Removal)
            const filteredData = new Uint8ClampedArray(data.length);
            filteredData.set(peeledData);

            for (let y = N; y < height - N; y++) {
                for (let x = N; x < width - N; x++) {
                    let weightedSum = 0;
                    let weightTotal = 0;

                    const centerVal = getPixel(x, y, peeledData);

                    // Compute weights for window
                    for (let j = -N; j <= N; j++) {
                        for (let i = -N; i <= N; i++) {
                            const pixelVal = getPixel(x + i, y + j, peeledData);
                            const delta = Math.abs(centerVal - pixelVal);
                            // Gaussian-like fuzzy weight
                            const weight = Math.exp(-(delta * delta) / (2 * sigma * sigma));
                            weightedSum += weight * pixelVal;
                            weightTotal += weight;
                        }
                    }

                    // Compute output pixel
                    const outputVal = weightTotal > 0 ? weightedSum / weightTotal : centerVal;
                    setPixel(x, y, outputVal, filteredData);
                }
            }

            return new ImageData(filteredData, width, height);
        }
    </script>
</body>
</html>